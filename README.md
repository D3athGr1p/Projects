# Projects

# Learning Roadmap

1. Rust

   - [ ] Ownership and Borrowing
     - [ ] Ownership
     - [ ] Borrowing (immutable and mutable)
     - [ ] References
     - [ ] Lifetimes
   - [ ] Traits
     - [ ] Defining traits
     - [ ] Implementing traits for types
     - [ ] Default method implementations
     - [ ] Derivable traits
   - [ ] Concurrency
     - [ ] Threads
     - [ ] Mutex and RwLock
     - [ ] Channels
     - [ ] Asynchronous programming (async/await, futures, tasks)
   - [ ] Memory Management
     - [ ] Smart pointers (Box, Rc, Arc)
     - [ ] Interior mutability (RefCell, Cell)
     - [ ] Drop trait
   - [ ] Macros
     - [ ] Declarative macros (macro_rules!)
     - [ ] Procedural macros (custom derive, attribute-like macros, function-like macros)
   - [ ] Unsafe Rust
     - [ ] Raw pointers
     - [ ] Unsafe functions and blocks
     - [ ] FFI (Foreign Function Interface)
   - [ ] Multithreading
   - [ ] Tokio
   - [ ] Rocket
   - [ ] Dioxus

2. Solidity

   - [ ] Assembly
   - [ ] Huff
   - [X] Basics
     - [X] Syntax and structure
     - [X] Comments
     - [X] Data types (integers, booleans, addresses, strings, bytes, fixed-point numbers)
   - [X] Control Structures
     - [X] if, else
     - [X] for, while loops
     - [X] break, continue
   - [X] Functions
     - [X] Function declaration and definition
     - [X] Function modifiers (public, private, internal, external)
     - [X] View and pure functions
     - [X] Payable functions
     - [X] Function overloading
   - [X] Contracts
     - [X] Contract declaration
     - [X] Contract inheritance
     - [X] Abstract contracts and interfaces
     - [X] Libraries
   - [X] State Variables
     - [X] Declaring state variables
     - [X] Visibility (public, private, internal)
   - [X] Storage, Memory, and Calldata
     - [X] Storage (persistent storage)
     - [X] Memory (temporary storage for function execution)
     - [ ] Calldata (data location for function inputs)
   - [X] Mappings and Arrays
     - [X] Fixed-size and dynamic arrays
     - [X] Structs
     - [X] Mappings
     - [X] Nested mappings and arrays
   - [X] Events and Logging
     - [X] Declaring events
     - [X] Emitting events
     - [X] Indexed parameters
   - [X] Modifiers
     - [X] Function modifiers
     - [X] Custom modifiers
     - [X] Applying modifiers to functions
   - [X] Inheritance and Interfaces
     - [X] Contract inheritance
     - [X] Using super
     - [X] Multiple inheritance and linearization
     - [X] Interfaces
     - [X] Abstract contracts
   - [X] Libraries
     - [X] Library declaration
     - [X] Using libraries for data types
     - [X] Linking libraries
   - [X] Ether and Address
     - [X] Address data type
     - [X] Sending and receiving Ether
     - [X] address payable vs address
     - [X] Low-level calls (call, delegatecall, staticcall)
   - [X] Error Handling
     - [X] Require, assert, and revert
     - [X] Custom error messages
   - [X] Access Control
     - [X] Ownership (Ownable pattern)
     - [X] Access control modifiers
   - [X] Smart Contract Security
     - [X] Reentrancy
     - [X] Integer overflow and underflow
     - [X] Tx.origin authentication
     - [ ] Front-running and race conditions
   - [ ] Gas and Optimization
     - [ ] Gas costs and limits
     - [ ] Gas optimization techniques
     - [ ] Best practices for efficient code
   - [X] Upgradeability
     - [X] Proxy patterns
     - [ ] Delegatecall-based proxies
     - [ ] Eternal storage
   - [ ] Testing and Deployment
     - [X] Writing tests for smart contracts
     - [-] Using frameworks like Foundry
     - [X] Contract deployment and migration
   - [X] Interacting with Other Contracts
     - [X] Calling external contracts
     - [X] Interface contracts
     - [X] Handling responses from external calls

3. DSA
4. Dynamic Programming
5. Leetcode challenges
6. Mathamatics
7. Hyperledger Fabric
8. codehawks
